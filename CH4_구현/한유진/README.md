* Q07

    럭키스트레이트 조건: 한 캐릭터 점수를 N이라 할 때, 자릿수 기준 N을 반으로 나눠
        
        왼쪽 각 자릿수의 합 == 오른쪽 각 자릿수의 합이면 럭키스트레이트

* Q09

    문자열 압축: 같은 값이 연속해서 나오는 것을 그 문자의 개수와 반복되는 값으로 표현하는 것

```
    예를 들어 

    1) ababcdcd -> 2ab2cd로 압축할 수 있다 (length : 8 -> 6)
    2) abcdabcd -> 2abcd로 압축할 수 있다  (length : 8 -> 5)

    따라서 이 문제를 풀기 위해서는 1 ~ len(s) // 2까지 개수로 문자열을 묶어서 가장 작은 길이가 나오는 문자열 압축길이를 구하면 된다!

    위에서 첫번째 예시는 2개씩 묶었을 때 최소가 되고 2번째 예시는 4개씩 묶었을 때 최소가 되는 것을 확인할 수 있다!

```

* Q10

    * NxN 자물쇠의 홈(0)을 모두 채워야 자물쇠가 열림
    * MxM 열쇠는 홈(0) 또는 돌기(1)로 되어 있음
    * 이때 열쇠는 회전 및 이동이 가능함
    * 자물쇠 영역에서는 자물쇠 홈 - 열쇠 돌기여야 하고 자물쇠 돌기 - 열쇠 돌기는 만나면 안됨! 그러나 영역 밖에선 상관 없음!

```
    위의 조건을 만족하는 열쇠인지 확인하기 위해서는 다음과 같은 절차가 필요

    1) key를 90도 rotate
    2) key를 좌우 아래로 움직이면서 자물쇠가 모두 1이 되는지 확인해줌
    3) 자물쇠가 모두 1이 되면 True를 반환 아니라면 False를 반환

    [구현한 함수]

    - rotate90clockwise()

        시계 방향으로 key를 회전시켜주기 위한 함수로 90도 회전할 때마다 각 key의 원소가 
        rotatedKey[j, N - i] = originalKey[i][j]임을 이용

        (예시)

        [[1,2,3],          [[7,4,1],
         [4,5,6],    ->     [8,5,2], 
         [7,8,9]]           [9,6,3]]


    - checkOpen()

        자물쇠의 모든 값이 1인지 확인해주기 위한 함수로 확장된 lock에서 원래 자물쇠의 값을 담고 있는 
        len(N) // 3 ~ len(N) // 3 + N 범위가 모두 1인지 확인해줌

    - solution()

        계산의 편의를 위해 이코테 책을 참고하였을 때 나온 방법인 기존의 lock을 원래 크기의 3배의 배열로 확장하는 방법을 사용해주었다.

```