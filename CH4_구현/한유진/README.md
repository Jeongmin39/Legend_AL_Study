# 문제 풀이

* Q07

    럭키스트레이트 조건: 한 캐릭터 점수를 N이라 할 때, 자릿수 기준 N을 반으로 나눠
        
        왼쪽 각 자릿수의 합 == 오른쪽 각 자릿수의 합이면 럭키스트레이트

* Q09

    문자열 압축: 같은 값이 연속해서 나오는 것을 그 문자의 개수와 반복되는 값으로 표현하는 것

```
    예를 들어 

    1) ababcdcd -> 2ab2cd로 압축할 수 있다 (length : 8 -> 6)
    2) abcdabcd -> 2abcd로 압축할 수 있다  (length : 8 -> 5)

    따라서 이 문제를 풀기 위해서는 1 ~ len(s) // 2까지 개수로 문자열을 묶어서 가장 작은 길이가 나오는 문자열 압축길이를 구하면 된다!

    위에서 첫번째 예시는 2개씩 묶었을 때 최소가 되고 2번째 예시는 4개씩 묶었을 때 최소가 되는 것을 확인할 수 있다!

```

* Q10

    * NxN 자물쇠의 홈(0)을 모두 채워야 자물쇠가 열림
    * MxM 열쇠는 홈(0) 또는 돌기(1)로 되어 있음
    * 이때 열쇠는 회전 및 이동이 가능함
    * 자물쇠 영역에서는 자물쇠 홈 - 열쇠 돌기여야 하고 자물쇠 돌기 - 열쇠 돌기는 만나면 안됨! 그러나 영역 밖에선 상관 없음!

```
    위의 조건을 만족하는 열쇠인지 확인하기 위해서는 다음과 같은 절차가 필요

    1) key를 90도 rotate
    2) key를 좌우 아래로 움직이면서 자물쇠가 모두 1이 되는지 확인해줌
    3) 자물쇠가 모두 1이 되면 True를 반환 아니라면 False를 반환

    [구현한 함수]

    - rotate90clockwise()

        시계 방향으로 key를 회전시켜주기 위한 함수로 90도 회전할 때마다 각 key의 원소가 
        rotatedKey[j, M -1 - i] = originalKey[i][j]임을 이용

        (예시)

        [[1,2,3],          [[7,4,1],
         [4,5,6],    ->     [8,5,2], 
         [7,8,9]]           [9,6,3]]


    - checkOpen()

        자물쇠의 모든 값이 1인지 확인해주기 위한 함수로 확장된 lock에서 원래 자물쇠의 값을 담고 있는 
        len(N) // 3 ~ len(N) // 3 + N 범위가 모두 1인지 확인해줌

    - solution()

        계산의 편의를 위해 이코테 책을 참고하였을 때 나온 방법인 기존의 lock을 원래 크기의 3배의 배열로 확장하는 방법을 사용해주었다.

```

* Q11

    Dummy 게임은 NxN 보드에서 매초마다 뱀이 이동하면서 사과를 먹으면 뱀의 길이가 길어지고 벽/자기 자신과 부딪히면 게임이 끝나는 게임이다

    뱀은 초기에 보드의 맨위 맨 좌측에서 시작하며 길이가 1이고 뱀의 머리는 오른쪽을 향한다. 매초마다 한 칸씩 움직이며 
    - 이동한 칸에 사과가 있음 -> 꼬리는 움직이지 x
    - 이동한 칸에 사과가 없음 -> 꼬리가 위치한 칸을 비워줌

    게임이 몇 초에 끝나는지 구하기 위해 다음과 같이 함수를 구현함

```

    - changeDirection(direction, turn)

        초기에 뱀이 방향 변환을 하는 횟수 L과 (x, direction) : x초 뒤에 방향 전환을 어디로 할 것인지 정보를 받게 된다. 회전은 왼쪽(L) 또는 오른쪽(D)으로만 가능하다.
        이때 왼쪽으로 회전하면 방향이 동 -> 북 -> 서 -> 남으로 변하는 것을 이용하여
        방향을 전환할 때 사용하는 변이 값들을
        move_x = [0, -1, 0, 1], move_y = [1, 0, -1, 0]으로 설정해주었는데 index의 오름차순순으로 동 북 서 남을 의미한다. 이때 각각의 값은 행렬에서 x 방향(row)으로 이동할 때는 북쪽과 남쪽에 해당하는 값만 바꿔주면 되고 y 방향(column)으로 이동할 때는 동쪽과 서쪽에 해당하는 값만 바꾸어주므로 다음과 같이 설정하였고
        direction이란 변수는 현재 뱀의 머리가 향한 방향을 의미해준다.

    - Dummy()

        게임을 시작하는 함수로 크게 초기 세팅 부분과 게임을 시작한 뒤 게임이 끝나는 초를 계산하는 부분으로 나눠져 있다.

        1) 초기 세팅

            - board area

                보드가 원래는 NxN이지만 상하좌우가 벽이므로 벽을 만났을 때 게임 종료를 시키기 위해서 padding을 0으로 해주었다.
                그 후에 진짜 보드 영역 부분만 값을 1로 설정해주었다.

            - apple's location

                보드에서 사과가 있는 영역의 값을 2로 설정해주었다.

            - direction change info

                게임 도중 뱀의 머리가 방향을 전환하는 때와 회전 방향에 대한 정보를 저장해주었다.

            - 초기 뱀의 위치 및 방향

                초기 뱀은 보드의 (1,1)에 위치하고 머리가 오른쪽을 향한다 했으므로 direction=0으로 설정했다.

        2) 게임

            * 종료 조건 : 이동 시 벽/자기 자신과 부딪히면 끝
            * 이동시 :

                - 사과 o : 그 칸에 있던 사과 없애고 뱀이 있음을 표시 board[nx][ny] = 3 -> 꼬리는 움직이지 x
                - 사과 x : 꼬리가 위치한 칸 비우기 -> board[nx][ny] = 1  

``` 

* Q12

    1) 벽면은 nxn
    2) 기둥 설치 조건 : 바닥 위 / 보의 한쪽 끝 / 또 다른 기둥 위

        기둥은 교차점 좌표 기준으로 위쪽 방향으로 설치함

    3) 보   설치 조건 : 한쪽 끝이 기둥 / 양쪽 끝이 보

        보는 교차점 좌표 기준으로 오른쪽 방향으로 설치함

    [입력값]
    - n
    - build_frame : [x, y, a, b] , a = 0(기둥)/1(보), b = 0(삭제)/1(설치)

    [출력값]
    - x로 오름차순 그후 y로 오름차순 정렬
    - [x, y, a]

* Q13

    1) 크기가 NxN인 도시

        도시의 각 칸은 빈 칸(0), 치킨집(2), 또는 집(1) 중 하나임
        이때 각 칸은 (r, c)이고 r,c >= 1
    2) 치킨 거리 : 집과 가장 가까운 치킨집 사이의 거리

        임의의 두 칸 (r1, c1) 과 (r2, c2)의 거리는 |r1- r2| + |c1 - c2|
        
    3) 도시의 치킨 거리 : 각 집의 치킨 거리의 합

        도시의 치킨 거리가 가장 작게 될 수 있는 치킨집의 개수는 최대 M개

    [입력값]
    - N M
    - 도시 정보 NxN

    [출력값]
    - 도시의 치킨 거리 합 최솟값 출력

```

    [구현]
    1) 도시 정보 NxN에서 치킨집과 집의 좌표 구하기

        chicken_store[], house[]

    2) python itertools의 combination을 이용하여 치킨집에서 M개씩 선택하는 조합 구하기
    3) 각 치킨집 조합별로 도시의 치킨 거리합 구하기 -> 그 중에서 최솟값 최종 출력

        a. 먼저 각 집별로 특정 치킨집 조합에 있는 치킨집과의 최소 거리 구하기
        b. 구한 각 집별로 구한 최소 거리를 더해서 도시의 치킨 거리 합 구하기
        c. 반복문을 돌면서 도시의 치킨 거리 합 최소 구하기

```

* Q14
