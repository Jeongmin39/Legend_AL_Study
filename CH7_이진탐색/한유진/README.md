
* Q27 정렬된 배열에서 특정 수의 개수 구하기

    N개의 원소롤 포함한 수열이 오름차순으로 정렬되어 있을 때,
    수열에 x가 등장하는 횟수를 계산 (없다면 -1 출력)
    이때 시간 복잡도가 O(log N)이어야 함

    첫 문제 풀이를 할 때는 이진 탐색을 재귀적으로 해가면서 x의 개수를 세어주었는데 이러면 시간 복잡도가 O(N logN)이 나옴

    따라서 이를 해결하기 위해서 처음으로 x가 나오는 곳의 인덱스와 마지막으로 x가 나오는 곳의 인덱스를 각각 이진탐색으로 찾고 이 인덱스를 이용하여 x의 계수를 구해줌! 

    [이진 탐색 구현]
    1. lower_bound와 upper_bound를 각각 처음에 0과 len(seq)-1로 초기화
    2. mid = (lower_bound + upper_bound)//2를 구해서 
       
        i. seq[mid]의 값이 x와 같으면 찾은 index를 업데이트하고 
            
            - first index를 찾을 땐 upper_bound = mid - 1로 업데이트
            - last index를 찾을 땐 lower_bound = mid + 1로 업데이트
        ii. seq[mid]의 값이 x보다 크면 upper_bound = mid - 1
        iii. seq[mid]의 값이 x보다 작으면 lower_bound = mid + 1 

* Q28 고정점 찾기

    고정점이란 수열의 원소 중 그 값이 인덱스와 동일한 원소를 의미함

    예를 들어, 수열 a = {-15, -4, 2, 8, 13}이 있을 때 a[2] = 2이므로 고정점은 2가 됨

    이 문제 역시 시간 복잡도가 O(log N)이어야 하므로 이진 탐색을 이용해 문제를 풀어야 함!

* Q29 공유기 설치

    집 N개가 수직선 위에 있을 때, 각 집의 좌표는 x1, x2, ..., xn 이다.

    이때 C개의 공유기를 N개의 집에 설치하여 가장 인접한 공유기 사이 거리가 최대가 되는 코드를 작성하기

    이를 위해서는 일단 
    1. 첫 번째 집과 두 번째 집 간의 거리와 첫 번째 집과 마지막 집 간의 거리를 알아야 한다.
        
        이 둘을 각각 firstGap과 lastGap으로 두고 이 둘의 중간 값을 mid로 설정

    2. 이 mid 값만큼 차이를 두면서 공유기가 설치가 됨을 확인하여 maxGap(가장 인접한 두 공유기 사이의 거리)를 업데이트 해준다.

    3. 이때 mid 만큼 거리를 두고 공유기가 설치가 되면 firstGap을 증가하여 주고 설치가 되지 않으면 lastGap을 줄여서 공유기가 설치되는 거리 차이를 조절해준다.

* Q30 가사 검색

