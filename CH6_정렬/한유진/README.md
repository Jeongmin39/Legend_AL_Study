* Q23

    학생 N명의 이름, 국어, 영어, 수학 점수가 주어질 때 아래과 같은 조건으로 정렬

    1) 국어 점수 내림차순
    2) 국어 점수가 같으면 영어 점수 오름차순
    3) 국어+영어 점수가 같으면 수학 점수 내림차순
    4) 모든 점수가 동일하면 이름 오름차순

* Q24
    1) 일직선 상 마을에 집이 여러 채 있는데 그 중 한 집에 안테나를 설치
    2) 이때 안테나로부터 각 집의 거리의 총 합이 최소가 되도록 하기 위해서는
    => 집의 위치의 리스트를 오름차순으로 정렬한 후 그 중에서 중간 값을 알아내면 된다!

    
* Q25

    실패율 = (스테이지 도달했으나 아직 클리어 못한 플레이어 수) / (스테이지 도달한 플레이어 수)

    [조건]
    - 스테이지 도달한 유저가 없는 경우 실패율 = 0
    - 실패율 같으면 작은 번호 스테이지부터 정렬

```

    [구현]
    실패율은 다음과 같이 계산할 수 있음

    i가 1~N이라고 할 때
    실패율 = stage가 i인 개수 / stage가 i 이상인 개수

    따라서

    totalPlayer 수를 for문을 돌면서 stage.count(i)만큼 빼서 업데이트 해주면 됨

```

* Q26

    두 묶음을 합쳐서 하나로 만드는 데에 A+B번의 비교가 필요하다.

    이때 최소한의 비교를 하기 위해서는 계속 최소한 작은 카드 묶음끼리 합쳐줘야 한다.

    따라서 Q06_무지의먹방라이브 때 사용한 heapq를 사용하여 코드를 짜주었다

    * heapq: priority queue로 모든 부모 노드가 자식 노드보다 값이 작은 최소 힙의 형태로 정렬된다.

```

    [구현]
    1) 카드 묶음 중에서 가장 작은 개수의 카드 묶음 2개를 선택해(pop) 비교 횟수 sum을 구한다.
        
        이 둘의 비교 횟수는 A+B이다.

    2) 비교 횟수 sum을 결과 값에 계속 더해주고, 카드 묶음 2개를 정렬한 것은 또 새로운 카드 묶음이 되니 heapq에 다시 push 해준다.
    3) 1)~2)를 반복하다가
        
        [종료 조건]heapq의 원소의 개수가 1개이면 하나의 카드 묶음만 남은 것이므로 종료한다.

```