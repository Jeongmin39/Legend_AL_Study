* Q23

    학생 N명의 이름, 국어, 영어, 수학 점수가 주어질 때 아래과 같은 조건으로 정렬

    1) 국어 점수 내림차순
    2) 국어 점수가 같으면 영어 점수 오름차순
    3) 국어+영어 점수가 같으면 수학 점수 내림차순
    4) 모든 점수가 동일하면 이름 오름차순

* Q24
    1) 일직선 상 마을에 집이 여러 채 있는데 그 중 한 집에 안테나를 설치
    2) 이때 안테나로부터 각 집의 거리의 총 합이 최소가 되도록 하기 위해서는
    => 집의 위치의 리스트를 오름차순으로 정렬한 후 그 중에서 중간 값을 알아내면 된다!

    
* Q25

    실패율 = (스테이지 도달했으나 아직 클리어 못한 플레이어 수) / (스테이지 도달한 플레이어 수)

    [조건]
    - 스테이지 도달한 유저가 없는 경우 실패율 = 0
    - 실패율 같으면 작은 번호 스테이지부터 정렬

```

    [구현]
    실패율은 다음과 같이 계산할 수 있음

    i가 1~N이라고 할 때
    실패율 = stage가 i인 개수 / stage가 i 이상인 개수

    따라서

    totalPlayer 수를 for문을 돌면서 stage.count(i)만큼 빼서 업데이트 해주면 됨

```

* Q26

    두 묶음을 합쳐서 하나로 만드는 데에 A+B번의 비교가 필요하다.

    이때 최소한의 비교를 하기 위해서는 계속 최소한 작은 카드 묶음끼리 합쳐줘야 한다.

    따라서 Q06_무지의먹방라이브 때 사용한 heapq를 사용하여 코드를 짜주었다

    * heapq: priority queue로 모든 부모 노드가 자식 노드보다 값이 작은 최소 힙의 형태로 정렬된다.

```

    [구현]
    1) 카드 묶음 중에서 가장 작은 개수의 카드 묶음 2개를 선택해(pop) 비교 횟수 sum을 구한다.
        
        이 둘의 비교 횟수는 A+B이다.

    2) 비교 횟수 sum을 결과 값에 계속 더해주고, 카드 묶음 2개를 정렬한 것은 또 새로운 카드 묶음이 되니 heapq에 다시 push 해준다.
    3) 1)~2)를 반복하다가
        
        [종료 조건]heapq의 원소의 개수가 1개이면 하나의 카드 묶음만 남은 것이므로 종료한다.

```

* [졍렬]가장 큰 수

    0 또는 양의 정수가 있을 때 만들 수 있는 가장 큰 수

    [구현 1] --> 시간 초과됨!

    1) numbers 배열에서 0과 양의 정수를 분리
        
        [종료 조건] 만약 양의 정수 개수가 0이라면 "0"을 반환

    2) 양의 정수가 들어있는 배열에서 아래 조건에 의해 배열에서 가장 큰 수를 계속 찾아 answer 배열에 append

        ```
            예를 들어 number = ['3', '330', '334' , '5', '9']라 할 때

            a. maxNum = number[0]으로 초기화
            b. for문을 돌면서 maxNum과 for num in number[1:]을 비교
                1. maxNum과 num의 길이가 같으면 큰게 maxNum
                2. 길이가 다르면
                    - 큰 것의 마지막이 0 => 작은 게 maxNum
                    - 큰 것의 마지막이 != 0 => 큰 게 maxNum
            c. 찾은 maxNum을 answer에 append해주고 number배열에서 제거
            d. a~c를 number 배열의 원소 개수가 1개가 아닐 때까지 반복
    3) 최종 answer 배열에 마지막 number 원소와 + zeros의 개수만큼 0 append

        ```


    [구현 2]

    1) numbers 배열에서 0과 양의 정수를 분리
        
        [종료 조건] 만약 양의 정수 개수가 0이라면 "0"을 반환
    2) list의 sort() method를 이용해 내림차순 사전순으로 정렬

        이때 '334', '3', '330'순으로 정렬되어야 하므로 num*3을 기준으로 정렬

        3을 곱한 이유는 numbers의 원소는 0 이상 1000 이하이기 때문에 
        '330', '3'과 같은 경우까지만 나올 수 있으므로
        '330' -> '330330330'
        '3' -> '333'이 되면 3이 더 큰 것으로 정렬되기 떄문! 
    3) 최종 answer에 정렬된 number + "0"*len(zeros)를 append

